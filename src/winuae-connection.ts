/**
 * WinUAE connection management and launcher
 * Connects to BartmanAbyss WinUAE fork with GDB RSP server
 *
 * The Bartman fork (winuae-gdb.exe) requires portable mode:
 *   1. Write a default.uae alongside the exe with hardware settings
 *   2. Launch with -portable -G -s debugging_features=gdbserver -s debugging_trigger=
 *   3. The -G flag suppresses the settings panel (use_gui=no in config does NOT work)
 * The GDB server listens on port 2345 by default.
 */

import { spawn, ChildProcess } from 'child_process';
import { GdbProtocol } from './gdb-protocol.js';
import * as path from 'path';
import * as fs from 'fs';
import * as os from 'os';

export interface WinUAEConfig {
  winuaePath: string;
  configFile: string;
  gdbPort: number;
}

export class WinUAEConnection {
  private config: WinUAEConfig;
  private process: ChildProcess | null = null;
  private protocol: GdbProtocol | null = null;
  private isConnected = false;
  private logFilePath: string | null = null;

  constructor(config: WinUAEConfig) {
    this.config = config;
  }

  /**
   * Parse a WinUAE .uae config file into key-value Map.
   * Skips comment lines (starting with ;) and blank lines.
   */
  private parseCfg(content: string): Map<string, string> {
    const out = new Map<string, string>();
    const lines = content.split(/[\r\n]+/g);
    const re = /^([^=]+)=(.*)$/;
    for (const line of lines) {
      if (line.startsWith(';') || line.trim() === '') continue;
      const match = line.match(re);
      if (match) {
        out.set(match[1], match[2]);
      }
    }
    return out;
  }

  /**
   * Stringify a config Map back to WinUAE .uae format.
   */
  private stringifyCfg(cfg: Map<string, string>): string {
    let out = '';
    cfg.forEach((value, key) => {
      out += `${key}=${value}\r\n`;
    });
    return out;
  }

  /**
   * Launch WinUAE (Bartman GDB fork) and connect to GDB server.
   *
   * Uses the portable mode approach (proven by vscode-amiga-debug):
   * 1. Read user's config file into a Map
   * 2. Merge GDB and GUI overrides
   * 3. Write as default.uae alongside winuae-gdb.exe
   * 4. Launch with -portable flag
   * 5. Retry-connect to TCP port 2345
   */
  async connect(): Promise<void> {
    if (this.isConnected) {
      throw new Error('Already connected to WinUAE');
    }

    // Find WinUAE GDB executable
    const exePath = path.join(this.config.winuaePath, 'winuae-gdb.exe');

    if (!fs.existsSync(exePath)) {
      throw new Error(
        `winuae-gdb.exe not found at ${exePath}. ` +
        `Download from https://github.com/BartmanAbyss/vscode-amiga-debug/tree/master/bin/win32 ` +
        `and place in ${this.config.winuaePath}`
      );
    }

    // Read user's config file as base, or start with empty Map
    let cfg = new Map<string, string>();
    if (this.config.configFile && fs.existsSync(this.config.configFile)) {
      try {
        const content = fs.readFileSync(this.config.configFile, 'utf8');
        cfg = this.parseCfg(content);
        console.error(`[WinUAE] Read config: ${this.config.configFile} (${cfg.size} settings)`);
      } catch (err) {
        console.error(`[WinUAE] Warning: could not read config ${this.config.configFile}: ${err}`);
      }
    } else {
      // Minimal A500 defaults when no user config
      cfg.set('quickstart', 'a500,1');
      cfg.set('ntsc', 'false');
      console.error('[WinUAE] No user config found, using minimal A500 defaults');
    }

    // Remove debugging settings from config file -- they must be passed
    // as -s CLI overrides because this WinUAE build (v4.10.1) ignores
    // debugging_features and use_gui when read from the config file.
    cfg.delete('debugging_features');
    cfg.delete('debugging_trigger');
    cfg.delete('use_gui');

    // Keep these in config (they do work from file)
    cfg.set('win32.start_not_captured', 'yes');
    cfg.set('win32.nonotificationicon', 'yes');
    cfg.set('boot_rom_uae', 'min');

    // Safety: remove statefiles that could interfere
    cfg.delete('statefile');

    // Write merged config as default.uae alongside winuae-gdb.exe
    const defaultUaePath = path.join(this.config.winuaePath, 'default.uae');

    // Back up existing default.uae if it exists and is not one we generated
    if (fs.existsSync(defaultUaePath)) {
      try {
        const existingContent = fs.readFileSync(defaultUaePath, 'utf8');
        if (!existingContent.includes('; Generated by mcp-winuae-emu')) {
          const backupPath = defaultUaePath + '.bak';
          fs.copyFileSync(defaultUaePath, backupPath);
          console.error(`[WinUAE] Backed up existing default.uae to ${backupPath}`);
        }
      } catch { /* ignore backup errors */ }
    }

    const header = '; Generated by mcp-winuae-emu for GDB debugging\r\n';
    fs.writeFileSync(defaultUaePath, header + this.stringifyCfg(cfg), 'utf8');
    console.error(`[WinUAE] Wrote config: ${defaultUaePath} (${cfg.size} settings)`);

    // Create log file
    const logDir = path.join(os.tmpdir(), 'winuae-mcp');
    if (!fs.existsSync(logDir)) {
      fs.mkdirSync(logDir, { recursive: true });
    }
    this.logFilePath = path.join(logDir, `winuae-${Date.now()}.log`);
    const logFd = fs.openSync(this.logFilePath, 'w');

    // Launch args: -portable reads default.uae, -G suppresses settings panel,
    // -s overrides enable GDB server (these MUST be CLI args, not in config file)
    const args = [
      '-portable',
      '-G',
      '-s', 'debugging_features=gdbserver',
      '-s', 'debugging_trigger=',
    ];

    console.error(`[WinUAE] Launching ${exePath} ${args.join(' ')}`);
    console.error(`[WinUAE] GDB port: ${this.config.gdbPort}`);
    console.error(`[WinUAE] Log file: ${this.logFilePath}`);

    this.process = spawn(exePath, args, {
      stdio: ['ignore', logFd, logFd],
      detached: false,
      cwd: this.config.winuaePath,
    });

    this.process.on('error', (err) => {
      console.error('[WinUAE] Process error:', err);
      try { fs.closeSync(logFd); } catch {}
    });

    this.process.on('exit', (code) => {
      console.error(`[WinUAE] Process exited with code ${code}`);
      try { fs.closeSync(logFd); } catch {}
      this.cleanup();
    });

    // Wait for GDB server to become available
    try {
      await this.waitForGdb();
    } catch (err) {
      // Close log fd and clean up if GDB connection fails after launch
      try { fs.closeSync(logFd); } catch {}
      this.cleanup();
      throw err;
    }
  }

  /**
   * Connect to an already-running WinUAE instance (no process spawn)
   */
  async connectExisting(): Promise<void> {
    if (this.isConnected) {
      throw new Error('Already connected to WinUAE');
    }

    console.error(`[WinUAE] Connecting to existing instance on port ${this.config.gdbPort}`);
    await this.waitForGdb();
  }

  /**
   * Try to quickly connect to an existing GDB server (fast, 2 attempts).
   * Returns true if connected, false if no server found.
   */
  private async tryQuickConnect(): Promise<boolean> {
    for (let attempt = 0; attempt < 2; attempt++) {
      try {
        this.protocol = new GdbProtocol();
        await this.protocol.connect('127.0.0.1', this.config.gdbPort);
        this.isConnected = true;
        console.error('[WinUAE] Connected to existing GDB server');
        return true;
      } catch {
        if (this.protocol) {
          this.protocol.disconnect();
          this.protocol = null;
        }
        if (attempt < 1) {
          await new Promise(resolve => setTimeout(resolve, 300));
        }
      }
    }
    return false;
  }

  /**
   * Smart connect: try existing GDB server first, then launch WinUAE if needed.
   * Returns a status message describing what happened.
   */
  async connectSmart(): Promise<string> {
    if (this.isConnected) {
      throw new Error('Already connected to WinUAE');
    }

    // Try quick connect to an already-running instance
    if (await this.tryQuickConnect()) {
      return `Connected to existing WinUAE GDB server on port ${this.config.gdbPort}`;
    }

    // No existing server -- launch WinUAE
    console.error('[WinUAE] No existing GDB server found, launching WinUAE...');
    await this.connect();
    return `Launched WinUAE and connected to GDB server on port ${this.config.gdbPort}`;
  }

  /**
   * Wait for GDB server with retry logic
   */
  private async waitForGdb(): Promise<void> {
    const maxAttempts = 30;
    const delayMs = 500;

    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      try {
        this.protocol = new GdbProtocol();
        await this.protocol.connect('127.0.0.1', this.config.gdbPort);

        this.isConnected = true;
        console.error('[WinUAE] Connected to GDB server');
        return;
      } catch (err) {
        if (this.protocol) {
          this.protocol.disconnect();
          this.protocol = null;
        }

        if (attempt < maxAttempts - 1) {
          await new Promise(resolve => setTimeout(resolve, delayMs));
        }
      }
    }

    throw new Error(`Failed to connect to WinUAE GDB server on port ${this.config.gdbPort} after ${maxAttempts} attempts`);
  }

  /**
   * Disconnect and kill WinUAE
   */
  async disconnect(): Promise<void> {
    if (!this.isConnected) {
      return;
    }

    this.cleanup();
    if (this.logFilePath) {
      console.error(`[WinUAE] Log file saved: ${this.logFilePath}`);
    }
    console.error('[WinUAE] Disconnected');
  }

  private cleanup(): void {
    this.isConnected = false;

    if (this.protocol) {
      this.protocol.disconnect();
      this.protocol = null;
    }

    if (this.process) {
      this.process.kill();
      this.process = null;
    }
  }

  /**
   * Get the GDB protocol handler
   */
  getProtocol(): GdbProtocol {
    if (!this.protocol || !this.isConnected) {
      throw new Error('Not connected to WinUAE');
    }
    return this.protocol;
  }

  /**
   * Check if connected
   */
  get connected(): boolean {
    return this.isConnected;
  }

  /**
   * Health check: try reading registers
   */
  async healthCheck(): Promise<boolean> {
    if (!this.isConnected || !this.protocol) {
      return false;
    }
    try {
      await this.protocol.readRegisters();
      return true;
    } catch {
      return false;
    }
  }
}
