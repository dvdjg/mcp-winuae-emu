/**
 * WinUAE connection management and launcher
 * Connects to BartmanAbyss WinUAE fork with GDB RSP server
 *
 * The Bartman fork (winuae-gdb.exe) requires portable mode:
 *   1. Write a default.uae alongside the exe with hardware settings
 *   2. Launch with -portable -G -s debugging_features=gdbserver -s debugging_trigger=
 *   3. The -G flag suppresses the settings panel (use_gui=no in config does NOT work)
 * The GDB server listens on port 2345 by default.
 *
 * WINUAE_TRACE=1: enable trace logging to %TEMP%/winuae-mcp/mcp-trace-*.log
 * WINUAE_GDB_MAX_ATTEMPTS: default 6 (3s at 500ms) - fail fast if no connection
 */

import { spawn, ChildProcess } from 'child_process';
import { GdbProtocol } from './gdb-protocol.js';
import { trace, traceErr } from './trace.js';
import * as path from 'path';
import * as fs from 'fs';
import * as os from 'os';

export interface WinUAEConfig {
  winuaePath: string;
  configFile: string;
  gdbPort: number;
}

export class WinUAEConnection {
  private config: WinUAEConfig;
  private process: ChildProcess | null = null;
  private protocol: GdbProtocol | null = null;
  private isConnected = false;
  private logFilePath: string | null = null;
  private floppies: Map<number, string> = new Map();

  constructor(config: WinUAEConfig) {
    this.config = config;
  }

  /**
   * Parse a WinUAE .uae config file into key-value Map.
   * Skips comment lines (starting with ;) and blank lines.
   */
  private parseCfg(content: string): Map<string, string> {
    const out = new Map<string, string>();
    const lines = content.split(/[\r\n]+/g);
    const re = /^([^=]+)=(.*)$/;
    for (const line of lines) {
      if (line.startsWith(';') || line.trim() === '') continue;
      const match = line.match(re);
      if (match) {
        out.set(match[1], match[2]);
      }
    }
    return out;
  }

  /**
   * Stringify a config Map back to WinUAE .uae format.
   */
  private stringifyCfg(cfg: Map<string, string>): string {
    let out = '';
    cfg.forEach((value, key) => {
      out += `${key}=${value}\r\n`;
    });
    return out;
  }

  /**
   * Launch WinUAE (Bartman GDB fork) and connect to GDB server.
   *
   * Uses the portable mode approach (proven by vscode-amiga-debug):
   * 1. Read user's config file into a Map
   * 2. Merge GDB and GUI overrides
   * 3. Write as default.uae alongside winuae-gdb.exe
   * 4. Launch with -portable flag
   * 5. Retry-connect to TCP port 2345
   */
  async connect(): Promise<void> {
    if (this.isConnected) {
      throw new Error('Already connected to WinUAE');
    }

    // Default: winuae-gdb.exe (32-bit, built by WinUAE-DBG). x64 outputs winuae-gdb-x64.exe
    let exeName = (process.env.WINUAE_EXE || 'winuae-gdb.exe').trim();
    let exePath = path.join(this.config.winuaePath, exeName);
    trace(`connect: exe=${exeName} path=${exePath} exists=${fs.existsSync(exePath)}`);

    if (!fs.existsSync(exePath)) {
      const fallback = path.join(this.config.winuaePath, 'winuae-gdb-x86.exe');
      trace(`Primary not found, trying fallback: ${fallback} exists=${fs.existsSync(fallback)}`);
      if (fs.existsSync(fallback)) {
        exePath = fallback;
        exeName = 'winuae-gdb-x86.exe';
      } else {
        throw new Error(
          `${exeName} not found at ${exePath}. ` +
          `Build WinUAE-DBG with "build.bat" (Win32) or set WINUAE_EXE.`
        );
      }
    }

    // Use -f to load user config directly (matches scripts/start-winuae-for-mcp-debug.ps1
    // which works; merging into default.uae in extension folder causes black screen).
    const useConfigFile = this.config.configFile && fs.existsSync(this.config.configFile);
    const configFileAbs = useConfigFile ? path.resolve(this.config.configFile) : '';

    if (!useConfigFile) {
      const cfg = new Map<string, string>([
        ['quickstart', 'a500,1'],
        ['ntsc', 'false'],
      ]);
      const defaultUaePath = path.join(this.config.winuaePath, 'default.uae');
      fs.writeFileSync(defaultUaePath, '; Generated by mcp-winuae-emu\r\n' + this.stringifyCfg(cfg), 'utf8');
      trace('No user config, wrote minimal default.uae');
    } else {
      trace(`Will load config with -f: ${configFileAbs}`);
    }

    // Create log file
    const logDir = path.join(os.tmpdir(), 'winuae-mcp');
    if (!fs.existsSync(logDir)) {
      fs.mkdirSync(logDir, { recursive: true });
    }
    this.logFilePath = path.join(logDir, `winuae-${Date.now()}.log`);
    const logFd = fs.openSync(this.logFilePath, 'w');

    // Launch args: load user config FIRST so our -s overrides apply on top.
    // -G is required for auto-start without config dialog.
    // WINUAE_HEADLESS=1 hides window completely (for CI/testing).
    const args: string[] = [];
    if (useConfigFile && configFileAbs) {
      args.push('-f', configFileAbs);
    }
    args.push('-portable');
    const headless = process.env.WINUAE_HEADLESS === '1';
    // -G: Start emulation immediately without showing config dialog
    // Without -G, WinUAE shows config dialog and waits for user to click Start
    args.push('-G');
    // -s headless=no: Show emulator window (by default -G enables headless mode)
    // This allows the user to see the emulation while debugging
    if (!headless) {
      args.push('-s', 'headless=no');
    }
    args.push('-s', 'debugging_features=gdbserver');
    // Do NOT override debugging_trigger: let config file decide (e.g. :a.exe).
    // F5/amiga-debug uses it to auto-load the program when GDB connects.
    if (process.env.WINUAE_DEBUGGING_TRIGGER !== undefined) {
      args.push('-s', `debugging_trigger=${process.env.WINUAE_DEBUGGING_TRIGGER}`);
    }
    // If no DF0: was set via winuae_insert_disk, use WINUAE_BOOT_ADF so the Amiga boots (avoids black screen).
    if (!this.floppies.has(0) && process.env.WINUAE_BOOT_ADF) {
      const bootAdf = path.resolve(process.env.WINUAE_BOOT_ADF);
      if (fs.existsSync(bootAdf)) {
        args.push('-s', `floppy0=${bootAdf}`);
        trace(`Boot ADF (WINUAE_BOOT_ADF): ${bootAdf}`);
      }
    }
    for (const [drive, diskPath] of this.floppies) {
      args.push('-s', `floppy${drive}=${diskPath}`);
    }

    trace(`Launching ${exePath} ${args.join(' ')}`);
    trace(`GDB port: ${this.config.gdbPort}, log: ${this.logFilePath}`);
    
    this.process = spawn(exePath, args, {
      stdio: ['ignore', logFd, logFd],
      detached: false,
      cwd: path.resolve(this.config.winuaePath),
      windowsHide: headless,
    });

    this.process.on('error', (err) => {
      traceErr('Process error', err);
      try { fs.closeSync(logFd); } catch {}
    });

    this.process.on('exit', (code) => {
      trace(`Process exited with code ${code}`);
      try { fs.closeSync(logFd); } catch {}
      this.cleanup();
    });

    const initialDelayMs = parseInt(process.env.WINUAE_GDB_INITIAL_DELAY_MS || '5000', 10);
    if (initialDelayMs > 0) {
      trace(`Waiting ${initialDelayMs}ms for WinUAE to start...`);
      await new Promise(resolve => setTimeout(resolve, initialDelayMs));
    }

    // Wait for GDB server to become available
    try {
      await this.waitForGdb();
    } catch (err) {
      // Close log fd and clean up if GDB connection fails after launch
      try { fs.closeSync(logFd); } catch {}
      this.cleanup();
      throw err;
    }
  }

  /**
   * Connect to an already-running WinUAE instance (no process spawn)
   */
  async connectExisting(): Promise<void> {
    if (this.isConnected) {
      throw new Error('Already connected to WinUAE');
    }

    trace(`connectExisting: port ${this.config.gdbPort}`);
    await this.waitForGdb();
  }

  /**
   * Try to quickly connect to an existing GDB server (fast, 2 attempts).
   * Returns true if connected, false if no server found.
   */
  private async tryQuickConnect(): Promise<boolean> {
    for (let attempt = 0; attempt < 2; attempt++) {
      try {
        this.protocol = new GdbProtocol();
        await this.protocol.connect('127.0.0.1', this.config.gdbPort);
        this.isConnected = true;
        trace('tryQuickConnect: connected');
        return true;
      } catch (e) {
        traceErr('tryQuickConnect attempt failed', e);
        if (this.protocol) {
          this.protocol.disconnect();
          this.protocol = null;
        }
        if (attempt < 1) {
          await new Promise(resolve => setTimeout(resolve, 300));
        }
      }
    }
    return false;
  }

  /**
   * Smart connect: try existing GDB server first, then launch WinUAE if needed.
   * Returns a status message describing what happened.
   */
  async connectSmart(): Promise<string> {
    if (this.isConnected) {
      throw new Error('Already connected to WinUAE');
    }

    // Try quick connect to an already-running instance
    if (await this.tryQuickConnect()) {
      return `Connected to existing WinUAE GDB server on port ${this.config.gdbPort}`;
    }

    trace('No existing GDB server, launching WinUAE...');
    await this.connect();
    return `Launched WinUAE and connected to GDB server on port ${this.config.gdbPort}`;
  }

  /**
   * Wait for GDB server. Default: 10 attempts Ã— 500ms = 5s (fail fast).
   * WINUAE_GDB_MAX_ATTEMPTS, WINUAE_GDB_DELAY_MS to override.
   */
  private async waitForGdb(): Promise<void> {
    const maxAttempts = parseInt(process.env.WINUAE_GDB_MAX_ATTEMPTS || '10', 10);
    const delayMs = parseInt(process.env.WINUAE_GDB_DELAY_MS || '500', 10);
    trace(`waitForGdb: maxAttempts=${maxAttempts} delayMs=${delayMs} (${(maxAttempts * delayMs) / 1000}s max)`);

    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      try {
        trace(`Attempt ${attempt + 1}/${maxAttempts} connecting to 127.0.0.1:${this.config.gdbPort}`);
        this.protocol = new GdbProtocol();
        await this.protocol.connect('127.0.0.1', this.config.gdbPort);

        this.isConnected = true;
        trace('Connected to GDB server');
        return;
      } catch (err) {
        traceErr(`Attempt ${attempt + 1} failed`, err);
        if (this.protocol) {
          this.protocol.disconnect();
          this.protocol = null;
        }

        if (attempt < maxAttempts - 1) {
          await new Promise(resolve => setTimeout(resolve, delayMs));
        }
      }
    }

    throw new Error(`Failed to connect to WinUAE GDB server on port ${this.config.gdbPort} after ${maxAttempts} attempts (${(maxAttempts * delayMs) / 1000}s)`);
  }

  /**
   * Restart WinUAE with updated configuration (preserves floppy state).
   */
  async restart(): Promise<string> {
    trace('Restarting with updated configuration...');
    this.cleanup();
    await this.connect();
    return `Restarted WinUAE and connected to GDB server on port ${this.config.gdbPort}`;
  }

  /**
   * Disconnect and kill WinUAE
   */
  async disconnect(): Promise<void> {
    if (!this.isConnected) {
      return;
    }

    this.cleanup();
    if (this.logFilePath) trace(`Log file: ${this.logFilePath}`);
    trace('Disconnected');
  }

  private cleanup(): void {
    this.isConnected = false;

    if (this.protocol) {
      this.protocol.disconnect();
      this.protocol = null;
    }

    if (this.process) {
      this.process.kill();
      this.process = null;
    }
  }

  /**
   * Get the GDB protocol handler
   */
  getProtocol(): GdbProtocol {
    if (!this.protocol || !this.isConnected) {
      throw new Error('Not connected to WinUAE');
    }
    return this.protocol;
  }

  /**
   * Check if connected
   */
  get connected(): boolean {
    return this.isConnected;
  }

  /**
   * Health check: try reading registers
   */
  async healthCheck(): Promise<boolean> {
    if (!this.isConnected || !this.protocol) {
      return false;
    }
    try {
      await this.protocol.readRegisters();
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Set or clear a floppy disk image for a drive (0-3).
   * Takes effect on next connect() or restart().
   */
  setFloppy(drive: number, filePath: string | null): void {
    if (drive < 0 || drive > 3) throw new Error('Drive must be 0-3');
    if (filePath) {
      this.floppies.set(drive, filePath);
    } else {
      this.floppies.delete(drive);
    }
  }

  getFloppies(): Map<number, string> {
    return new Map(this.floppies);
  }
}
