/**
 * WinUAE connection management and launcher
 * Connects to BartmanAbyss WinUAE fork with GDB RSP server
 *
 * The Bartman fork (winuae-gdb.exe) requires portable mode:
 *   1. Write a default.uae alongside the exe with hardware settings
 *   2. Launch with -portable -G -s debugging_features=gdbserver -s debugging_trigger=
 *   3. The -G flag suppresses the settings panel (use_gui=no in config does NOT work)
 * The GDB server listens on port 2345 by default.
 */

import { spawn, ChildProcess } from 'child_process';
import { GdbProtocol } from './gdb-protocol.js';
import * as path from 'path';
import * as fs from 'fs';
import * as os from 'os';

export interface WinUAEConfig {
  winuaePath: string;
  configFile: string;
  gdbPort: number;
}

export class WinUAEConnection {
  private config: WinUAEConfig;
  private process: ChildProcess | null = null;
  private protocol: GdbProtocol | null = null;
  private isConnected = false;
  private logFilePath: string | null = null;
  private floppies: Map<number, string> = new Map();

  constructor(config: WinUAEConfig) {
    this.config = config;
  }

  /**
   * Parse a WinUAE .uae config file into key-value Map.
   * Skips comment lines (starting with ;) and blank lines.
   */
  private parseCfg(content: string): Map<string, string> {
    const out = new Map<string, string>();
    const lines = content.split(/[\r\n]+/g);
    const re = /^([^=]+)=(.*)$/;
    for (const line of lines) {
      if (line.startsWith(';') || line.trim() === '') continue;
      const match = line.match(re);
      if (match) {
        out.set(match[1], match[2]);
      }
    }
    return out;
  }

  /**
   * Stringify a config Map back to WinUAE .uae format.
   */
  private stringifyCfg(cfg: Map<string, string>): string {
    let out = '';
    cfg.forEach((value, key) => {
      out += `${key}=${value}\r\n`;
    });
    return out;
  }

  /**
   * Launch WinUAE (Bartman GDB fork) and connect to GDB server.
   *
   * Uses the portable mode approach (proven by vscode-amiga-debug):
   * 1. Read user's config file into a Map
   * 2. Merge GDB and GUI overrides
   * 3. Write as default.uae alongside winuae-gdb.exe
   * 4. Launch with -portable flag
   * 5. Retry-connect to TCP port 2345
   */
  async connect(): Promise<void> {
    if (this.isConnected) {
      throw new Error('Already connected to WinUAE');
    }

    // Find WinUAE GDB executable
    const exePath = path.join(this.config.winuaePath, 'winuae-gdb.exe');

    if (!fs.existsSync(exePath)) {
      throw new Error(
        `winuae-gdb.exe not found at ${exePath}. ` +
        `Download from https://github.com/BartmanAbyss/vscode-amiga-debug/tree/master/bin/win32 ` +
        `and place in ${this.config.winuaePath}`
      );
    }

    // Use -f to load user config directly (matches scripts/start-winuae-for-mcp-debug.ps1
    // which works; merging into default.uae in extension folder causes black screen).
    const useConfigFile = this.config.configFile && fs.existsSync(this.config.configFile);
    const configFileAbs = useConfigFile ? path.resolve(this.config.configFile) : '';

    if (!useConfigFile) {
      // No user config: write minimal default.uae (quickstart A500)
      const cfg = new Map<string, string>([
        ['quickstart', 'a500,1'],
        ['ntsc', 'false'],
      ]);
      const defaultUaePath = path.join(this.config.winuaePath, 'default.uae');
      fs.writeFileSync(defaultUaePath, '; Generated by mcp-winuae-emu\r\n' + this.stringifyCfg(cfg), 'utf8');
      console.error(`[WinUAE] No user config, wrote minimal default.uae`);
    } else {
      console.error(`[WinUAE] Will load config with -f: ${configFileAbs}`);
    }

    // Create log file
    const logDir = path.join(os.tmpdir(), 'winuae-mcp');
    if (!fs.existsSync(logDir)) {
      fs.mkdirSync(logDir, { recursive: true });
    }
    this.logFilePath = path.join(logDir, `winuae-${Date.now()}.log`);
    const logFd = fs.openSync(this.logFilePath, 'w');

    // Launch args: same as scripts/start-winuae-for-mcp-debug.ps1 (which works).
    // -portable -G, GDB settings, floppies, then -f configFile to load user config directly.
    const args: string[] = [
      '-portable',
      '-G',
      '-s', 'debugging_features=gdbserver',
      '-s', 'debugging_trigger=',
    ];
    if (process.env.WINUAE_USE_GUI_NO !== '0') {
      args.splice(2, 0, '-s', 'use_gui=no');  // Start directly into emulation (no config window)
    }

    // Inject floppy disk settings as CLI overrides
    for (const [drive, diskPath] of this.floppies) {
      args.push('-s', `floppy${drive}=${diskPath}`);
    }

    // Load user config with -f (same as start-winuae-for-mcp-debug.ps1)
    if (useConfigFile && configFileAbs) {
      args.push('-f', configFileAbs);
    }

    console.error(`[WinUAE] Launching ${exePath} ${args.join(' ')}`);
    console.error(`[WinUAE] GDB port: ${this.config.gdbPort}`);
    console.error(`[WinUAE] Log file: ${this.logFilePath}`);

    this.process = spawn(exePath, args, {
      stdio: ['ignore', logFd, logFd],
      detached: false,
      cwd: this.config.winuaePath,
    });

    this.process.on('error', (err) => {
      console.error('[WinUAE] Process error:', err);
      try { fs.closeSync(logFd); } catch {}
    });

    this.process.on('exit', (code) => {
      console.error(`[WinUAE] Process exited with code ${code}`);
      try { fs.closeSync(logFd); } catch {}
      this.cleanup();
    });

    // Give WinUAE time to start and open GDB port (unattended: no user clicking Start)
    const initialDelayMs = parseInt(process.env.WINUAE_GDB_INITIAL_DELAY_MS || '3000', 10);
    if (initialDelayMs > 0) {
      console.error(`[WinUAE] Waiting ${initialDelayMs}ms for WinUAE to start...`);
      await new Promise(resolve => setTimeout(resolve, initialDelayMs));
    }

    // Wait for GDB server to become available
    try {
      await this.waitForGdb();
    } catch (err) {
      // Close log fd and clean up if GDB connection fails after launch
      try { fs.closeSync(logFd); } catch {}
      this.cleanup();
      throw err;
    }
  }

  /**
   * Connect to an already-running WinUAE instance (no process spawn)
   */
  async connectExisting(): Promise<void> {
    if (this.isConnected) {
      throw new Error('Already connected to WinUAE');
    }

    console.error(`[WinUAE] Connecting to existing instance on port ${this.config.gdbPort}`);
    await this.waitForGdb();
  }

  /**
   * Try to quickly connect to an existing GDB server (fast, 2 attempts).
   * Returns true if connected, false if no server found.
   */
  private async tryQuickConnect(): Promise<boolean> {
    for (let attempt = 0; attempt < 2; attempt++) {
      try {
        this.protocol = new GdbProtocol();
        await this.protocol.connect('127.0.0.1', this.config.gdbPort);
        this.isConnected = true;
        console.error('[WinUAE] Connected to existing GDB server');
        return true;
      } catch {
        if (this.protocol) {
          this.protocol.disconnect();
          this.protocol = null;
        }
        if (attempt < 1) {
          await new Promise(resolve => setTimeout(resolve, 300));
        }
      }
    }
    return false;
  }

  /**
   * Smart connect: try existing GDB server first, then launch WinUAE if needed.
   * Returns a status message describing what happened.
   */
  async connectSmart(): Promise<string> {
    if (this.isConnected) {
      throw new Error('Already connected to WinUAE');
    }

    // Try quick connect to an already-running instance
    if (await this.tryQuickConnect()) {
      return `Connected to existing WinUAE GDB server on port ${this.config.gdbPort}`;
    }

    // No existing server -- launch WinUAE
    console.error('[WinUAE] No existing GDB server found, launching WinUAE...');
    await this.connect();
    return `Launched WinUAE and connected to GDB server on port ${this.config.gdbPort}`;
  }

  /**
   * Wait for GDB server with retry logic (unattended: allow enough time for WinUAE to open port)
   */
  private async waitForGdb(): Promise<void> {
    const maxAttempts = parseInt(process.env.WINUAE_GDB_MAX_ATTEMPTS || '60', 10);  // 60 * 500ms = 30s
    const delayMs = parseInt(process.env.WINUAE_GDB_DELAY_MS || '500', 10);

    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      try {
        this.protocol = new GdbProtocol();
        await this.protocol.connect('127.0.0.1', this.config.gdbPort);

        this.isConnected = true;
        console.error('[WinUAE] Connected to GDB server');
        return;
      } catch (err) {
        if (this.protocol) {
          this.protocol.disconnect();
          this.protocol = null;
        }

        if (attempt < maxAttempts - 1) {
          await new Promise(resolve => setTimeout(resolve, delayMs));
        }
      }
    }

    throw new Error(`Failed to connect to WinUAE GDB server on port ${this.config.gdbPort} after ${maxAttempts} attempts`);
  }

  /**
   * Restart WinUAE with updated configuration (preserves floppy state).
   */
  async restart(): Promise<string> {
    console.error('[WinUAE] Restarting with updated configuration...');
    this.cleanup();
    await this.connect();
    return `Restarted WinUAE and connected to GDB server on port ${this.config.gdbPort}`;
  }

  /**
   * Disconnect and kill WinUAE
   */
  async disconnect(): Promise<void> {
    if (!this.isConnected) {
      return;
    }

    this.cleanup();
    if (this.logFilePath) {
      console.error(`[WinUAE] Log file saved: ${this.logFilePath}`);
    }
    console.error('[WinUAE] Disconnected');
  }

  private cleanup(): void {
    this.isConnected = false;

    if (this.protocol) {
      this.protocol.disconnect();
      this.protocol = null;
    }

    if (this.process) {
      this.process.kill();
      this.process = null;
    }
  }

  /**
   * Get the GDB protocol handler
   */
  getProtocol(): GdbProtocol {
    if (!this.protocol || !this.isConnected) {
      throw new Error('Not connected to WinUAE');
    }
    return this.protocol;
  }

  /**
   * Check if connected
   */
  get connected(): boolean {
    return this.isConnected;
  }

  /**
   * Health check: try reading registers
   */
  async healthCheck(): Promise<boolean> {
    if (!this.isConnected || !this.protocol) {
      return false;
    }
    try {
      await this.protocol.readRegisters();
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Set or clear a floppy disk image for a drive (0-3).
   * Takes effect on next connect() or restart().
   */
  setFloppy(drive: number, filePath: string | null): void {
    if (drive < 0 || drive > 3) throw new Error('Drive must be 0-3');
    if (filePath) {
      this.floppies.set(drive, filePath);
    } else {
      this.floppies.delete(drive);
    }
  }

  getFloppies(): Map<number, string> {
    return new Map(this.floppies);
  }
}
